<!-- SAVE_AS: spec/features/carousel-scroll-lock/plan.md -->

# План реализации

**План:** Обеспечить блокировку вертикального скролла при горизонтальном свайпе внутри `vue3-carousel`, максимально используя встроенные настройки плагина и добавляя собственные обработчики только при необходимости.

## Источники данных / схемы

- Изучить текущие компоненты `BannerCarousel.vue` и `PopularCarousel.vue`: убедиться, что они используют общую конфигурацию и определить точки расширения (слоты, пропсы, события).
- Проанализировать официальную документацию и исходники `vue3-carousel` (`DEFAULT_CONFIG`, описания `touchDrag`, `mouseDrag`, `preventExcessiveDragging`, `touch-action`), чтобы понять, есть ли готовая настройка для ограничения вертикальных жестов.
- Проверить, как сейчас настроены стили контейнера (наличие `touch-action`, `overflow`, `pointer-events`) и влияет ли Tailwind на обработку жестов.

## Контракты и интерфейсы

- Уточнить, требуется ли новый проп компонента (например, `lockVerticalScroll`), либо достаточно внутренней конфигурации. Если проп нужен — определить его тип, значение по умолчанию и влияние на API.
- При использовании настроек плагина задокументировать и сохранить текущие пропсы (`wrapAround`, `itemsToShow`, навигационные слоты), чтобы изменение не ломало обратную совместимость.
- Если добавляются кастомные обработчики, определить интерфейс хука/композиции (например, `useCarouselDragGuard`) для повторного использования в обеих каруселях.

## Архитектура / Компоненты

- **Этап 1. Анализ плагина:** протестировать комбинации настроек (`touchDrag` как объект с `threshold`, `preventExcessiveDragging`, CSS `touch-action`) на демо или локально, чтобы понять, решает ли это проблему без кастомного кода.
- **Этап 2. Настройка конфигурации:** если найдено решение через пропсы, обновить компоненты, добавив необходимые опции или CSS. Иначе внедрить кастомные обработчики pointer/touch:
  - На `pointerdown`/`touchstart` сохранить стартовые координаты, сбрасывая состояния при множественных касаниях.
  - На `pointermove`/`touchmove` вычислять дельты и определять доминирующее направление; при горизонтальном преобладании вызывать `preventDefault()` и переключать слайд (используя публичные методы `Carousel`).
  - Гарантировать корректное удаление слушателей на `pointerup`/`touchend`, `pointercancel`, `touchcancel` и при `beforeUnmount`.
  - Добавить `touch-action: pan-y` или `pan-x` в зависимости от выбранного подхода, чтобы браузер корректно интерпретировал жесты.
- **Этап 3. Тестирование:** покрыть сценарии юнит/компонентными тестами (симуляция touch/pointer событий), а также описать ручные проверки на iOS/Android/desktop.
- **Этап 4. Документация и обратная связь:** обновить README/стори для карусели, описать выбранный способ блокировки и добавить инструкции для QA.

## Риски

- Встроенные настройки плагина могут не обеспечивать полную блокировку вертикального скролла; придётся писать кастомную реализацию с повышенным риском ошибок.
- iOS Safari может игнорировать `touch-action` или `preventDefault` на пассивных слушателях; потребуется тщательное тестирование и аккуратная настройка опций слушателей.
- Возможные конфликты с другими обработчиками скролла или глобальными слушателями в проекте.
- Вероятность регрессий в accessibility (например, фокус застрянет внутри карусели) при неправильном управлении событиями.

## Допущения

- Есть возможность запускать проект локально и тестировать на реальных устройствах или эмуляторах.
- QA-команда доступна для ручных проверок на ключевых устройствах.
- Тестовый стенд поддерживает обновлённые настройки карусели без дополнительных доработок бэкенда.
